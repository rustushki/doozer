let s:queue = []
let s:jobResult = []
let s:origDir = ""

" doozer#build#jobOutputHandler {{{2
" Handle output from executing jobs.  This handler will store each line of
" output in a list for later use.
function! doozer#build#jobOutputHandler(jobId, data, event)
	for l:line in a:data
		call add(s:jobResult, l:line)
	endfor
endfunction

" doozer#build#jobExitHandler {{{2
" Handle the end of a job.  It does so by checking for errors in the QuickFix
" list, cleaning the errors, and starting the next job in the job queue.  If
" there were errors with the job exiting, the handler will flush the job queue
" and cease executing new jobs.  If jobId is -1, this handler can be used to
" start the processing the queue.  This is unfortunate, but we're waiting for
" Neovim to support an on_start callback for job_start().
function! doozer#build#jobExitHandler(jobId, data, event)
	" If we're not starting the asynchronous loop,
	if a:jobId != -1
		" cd back to the original directory.
		execute 'cd ' . s:origDir

		" Parse the results using 'errorformat' and update QuickFix.
		cgetexpr s:jobResult

		" Flush the Job Result.
		let s:jobResult = []

		" Cleanup the QuickFix list by removing junk output.
		call doozer#build#cleanQfList()

		" Count the Build Errors.
		let l:errorCount = doozer#build#countBuildErrors()
		echom "done with " . l:errorCount . " errors"

		" Do not continue executing jobs if there were errors.
		if l:errorCount > 0
			call doozer#build#flushQueue()
			return
		endif
	endif

	" Dequeue the next job.
	let l:job = doozer#build#dequeue()
	if l:job != {}
		" cd to the project
		let s:origDir = getcwd()
		execute 'cd ' . l:job.root

		" Set up the job callbacks.
		let l:callbacks = {
			\ 'on_stdout': function('doozer#build#jobOutputHandler'),
			\ 'on_stderr': function('doozer#build#jobOutputHandler'),
			\ 'on_exit': function('doozer#build#jobExitHandler')
			\ }

		" Fetch the Target Action
		let l:targetAction = l:job.targetAction

		echom "building " . l:job.name
		call jobstart(['sh', '-c', &makeprg . ' ' . l:targetAction], l:callbacks)
	
	" If there are no jobs left to execute, then all must have built OK.  It's
	" safe to close the QuickFix list.
	else
		cclose
	endif

endfunction

" doozer#build#queue {{{2
" Queue a job for later execution by execQueue().
func! doozer#build#queue(name, targetAction, root, isCommand)
	let l:job              = {}
	let l:job.name         = a:name
	let l:job.targetAction = a:targetAction
	let l:job.root         = a:root
	let l:job.isCommand    = a:isCommand
	call add(s:queue, l:job)
endfunc

" doozer#build#dequeue {{{2
" Dequeue a job (presumably for execution).
func! doozer#build#dequeue()
	let l:job = {}

	if len(s:queue) > 0
		" Retrieve the first element.
		let l:job = s:queue[0]

		" Chop off the first element.
		let s:queue = s:queue[1:-1]
	endif

	return l:job
endfunc

" doozer#build#flushQueue {{{2
" Discards all jobs in the job queue.
func! doozer#build#flushQueue()
	let s:queue = []
endfunc

" doozer#build#execQueue {{{2
" Dequeue each job from the job queue and execute them in order.
func! doozer#build#execQueue()
	" Neovim.
	if has('nvim')
		call doozer#build#jobExitHandler(-1, -1, -1)

	" Normal Vim.
	else
		while len(s:queue) > 0
			let l:job = doozer#build#dequeue()
			if l:job != {}
				" Exec the target on the project, but stop if any errors.
				if doozer#build#doJob(l:job)
					break
				endif
			endif
		endwhile

		call doozer#build#cleanQfList()
	endif
endfunc

" doozer#build#doJob {{{2
" Given a job, execute it synchronously: cd to the project root and execute
" the target.  Return count of errors generated by the target.
func! doozer#build#doJob(job)
	" Fetch the Target Action
	let l:targetAction = a:job.targetAction

	" Build the target if it exists.
	if l:targetAction != ""
		" cd to the project
		let s:origDir = getcwd()
		execute 'cd ' . a:job.root

		" Do the target as a build target or command depending on the
		" isCommand flag.
		let l:executor = ""
		if a:job.isCommand
			let l:executor = '!'
		else
			let l:executor = 'silent! make'
		endif

		" Run the target action.
		execute l:executor . ' ' . l:targetAction

		" cd back to the original directory.
		execute 'cd ' . s:origDir
	endif

	return doozer#build#countBuildErrors()
endfunc

" doozer#build#countBuildErrors {{{2
" Count the valid/non-junk entries in the QuickFix List.
func! doozer#build#countBuildErrors()
	let l:count = 0

	for l:qfrec in getqflist()
		if l:qfrec.bufnr != 0
			let l:count += 1
		endif
	endfor

	return l:count
endfunc

" doozer#build#cleanQfList {{{2
" Cleanup the QuickFix list to remove all lines that did not parse against
" 'errorformat'.
func! doozer#build#cleanQfList()
	" Build a Cleaner QuickFix List.
	let l:cleanQfList = []
	for l:entry in getqflist()
		if l:entry.valid
			call add(l:cleanQfList, l:entry)
		endif
	endfor

	" Repopulate the QuickFix List with the Clean Version.
	call setqflist(l:cleanQfList)
endfunc

" vim:ft=vim foldmethod=marker sw=4
